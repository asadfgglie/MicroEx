line&1:
	$ lexer got token: `PROGRAM`, scan: `program`
	$ lexer got token: `ID`, scan: `test_function`
START test_function
comment&declare_all_usaged_temp_variable&0:
J temp_var_declare&test_function
start&test_function:
	> program_title -> program id (program_title -> program test_function)
		> Program start with name: `test_function`

line&2:
line&3:
	$ lexer got token: `BEGIN`, scan: `begin`
line&4:
	$ lexer got token: `FN`, scan: `fn`
	$ lexer got token: `INTEGER`, scan: `integer`
	> type -> INTEGER
	$ lexer got token: `ID`, scan: `test`
	$ lexer got token: `LEFT_PARENT`, scan: `(`
	> function_statement_head -> FN type ID LEFT_PARENT (function_statement_head -> fn integer test ()
	$ lexer got token: `INTEGER`, scan: `integer`
	> type -> INTEGER
	$ lexer got token: `ID`, scan: `a`
	$ lexer got token: `RIGHT_PARENT`, scan: `)`
	> id -> ID (id -> fn&test&a)
	> arg -> type id (arg -> integer fn&test&a)
	> arg_list -> arg (arg_list -> integer fn&test&a)
	> function_statement_prefix -> function_statement_head RIGHT_PARENT (function_statement_prefix -> fn integer test (integer fn&test&a))
fn_name&test:
fn_arg&fn&test&a:
DECLARE fn&test&a integer
DECLARE test function
DECLARE fn&test&ret&integer integer
line&5:
	$ lexer got token: `RETURN`, scan: `return`
	$ lexer got token: `ID`, scan: `a`
	$ lexer got token: `SEMICOLON`, scan: `;`
	> id -> ID (id -> fn&test&a)
	> expression -> id (expression -> fn&test&a)
line&6:
	$ lexer got token: `ENDFN`, scan: `endfn`
I_STORE fn&test&a fn&test&ret&integer
RETURN fn&test&ret&integer
	> function_statement -> function_statement_prefix RETURN expression SEMICOLON FNEND

	> statement -> function_statement
	> statement_list -> statement
line&7:
line&8:
	$ lexer got token: `DECLARE`, scan: `declare`
	$ lexer got token: `ID`, scan: `a`
	$ lexer got token: `LEFT_BRACKET`, scan: `[`
	$ lexer got token: `INTEGER_LITERAL`, scan: `10`
I_STORE 10 temp&integer&0
	> expression -> INTEGER_LITERAL (expression -> 10)
	$ lexer got token: `RIGHT_BRACKET`, scan: `]`
	> array_dimension -> LEFT_BRACKET expression RIGHT_BRACKET (array_dimension -> [10])
	> array_dimension_list -> array_dimension (array_dimension_list -> [10])
	$ lexer got token: `AS`, scan: `as`
	> id -> ID array_dimension_list (id -> a[10])
	> id_list -> id (id_list -> a[10])
	$ lexer got token: `INTEGER`, scan: `integer`
	> type -> INTEGER
	$ lexer got token: `SEMICOLON`, scan: `;`
DECLARE a integer_array 10
I_STORE 0 a[0]
I_STORE 0 a[1]
I_STORE 0 a[2]
I_STORE 0 a[3]
I_STORE 0 a[4]
I_STORE 0 a[5]
I_STORE 0 a[6]
I_STORE 0 a[7]
I_STORE 0 a[8]
I_STORE 0 a[9]
	> declare_statement -> declare id_list as type semicolon (declare_statement -> declare a[10] as integer;)

	> statement -> declare_statement
	> statement_list -> statement_list statement
line&9:
	$ lexer got token: `ID`, scan: `a`
	$ lexer got token: `LEFT_BRACKET`, scan: `[`
	$ lexer got token: `INTEGER_LITERAL`, scan: `0`
I_STORE 0 temp&integer&1
	> expression -> INTEGER_LITERAL (expression -> 0)
	$ lexer got token: `RIGHT_BRACKET`, scan: `]`
	> array_dimension -> LEFT_BRACKET expression RIGHT_BRACKET (array_dimension -> [0])
	> array_dimension_list -> array_dimension (array_dimension_list -> [0])
	$ lexer got token: `ASSIGN`, scan: `:=`
	> id -> ID array_dimension_list (id -> a[0])
	$ lexer got token: `ID`, scan: `test`
	$ lexer got token: `LEFT_PARENT`, scan: `(`
	$ lexer got token: `ID`, scan: `a`
	$ lexer got token: `RIGHT_PARENT`, scan: `)`
	> id -> ID (id -> a)
	> expression -> id (expression -> a)
	> expression_list -> expression (expression_list -> a[0])
	> Calculating offset for array access.
comment&Calculating_offset&1:
I_STORE 0 temp&integer&3
I_STORE 1 temp&integer&4
I_MUL temp&integer&4 0 temp&integer&6
I_ADD temp&integer&3 temp&integer&6 temp&integer&5
I_STORE temp&integer&5 temp&integer&3
I_MUL temp&integer&4 10 temp&integer&6
I_STORE temp&integer&6 temp&integer&4
I_STORE a[temp&integer&3] temp&integer&7
	> extract array access: expression -> a[0]
I_STORE temp&integer&7 fn&test&a
CALL test temp&integer&2
	> expression -> ID LEFT_PARENT expression_list RIGHT_PARENT (expression -> test(temp&integer&7[0]))
	$ lexer got token: `SEMICOLON`, scan: `;`
	> Calculating offset for array access.
comment&Calculating_offset&2:
I_STORE 0 temp&integer&8
I_STORE 1 temp&integer&9
Index Error: Array index out of bounds.
	at line (9:20)
