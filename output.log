Script started on 2025-05-22 02:36:45+08:00 [TERM="xterm-256color" TTY="/dev/pts/4" COLUMNS="132" LINES="16"]
[?2004h]0;asadfgglie-msi@asadfgglie-msi: ~/complier[01;32masadfgglie-msi@asadfgglie-msi[00m:[01;34m~/complier[00m$ cat mice[Kroex/min[Kcroex_c[Kscanner.l 
[?2004l
%{
    #include <stdbool.h>
    #include <math.h>
    #include "../lib/uthash.h"
    #include "../microex/util.h"
    #include "../build/y.tab.h"

    unsigned long long line_count = 1, line_word_count = 0;
    bool is_multi_line_comment = false;
    char error_msg[MAX_ERROR_MSG_LEN];
%}

empty_word [ \t]+
new_line \n

line_comment %%(((\n)?)|([^\n%][^\n]*((\n)?)))
multi_line_comment "%%%"

program [Pp][Rr][Oo][Gg][Rr][Aa][Mm]

begin [Bb][Ee][Gg][Ii][Nn]
end [Ee][Nn][Dd]
read [Rr][Ee][Aa][Dd]
write [Ww][Rr][Ii][Tt][Ee]
id ([a-zA-Z]|_)+([0-9]*|_|[a-zA-Z])
integer_literal ([1-9](_?[0-9]+)*)|[0-9]
float_literal (({integer_literal}\.)|(\.(([0-9]+)|([0-9](_?[0-9]+)*)))|({integer_literal}\.(([0-9]*)|([0-9](_?[0-9]+)*))))
exp_float_literal {float_literal}[Ee][+-]?{integer_literal}
string_literal \"(([^\n\"\\])|(\\\")|(\\\\)|(\\n)|(\\t)|(\\b)|(\\\'))*\"
left_parent "("
right_parent ")"
left_bracket "["
right_bracket "]"
semicolon ";"
comma ","
assign ":="
plus "+"
minus "-"
multiply "*"
division "/"
not_equal "!="
equal "=="
great ">"
less "<"
great_equal ">="
less_equal "<="
if [iI][fF]
then [Tt][Hh][Ee][Nn]
else [Ee][Ll][Ss][Ee]
endif [Ee][Nn][Dd][Ii][Ff]
for [Ff][Oo][Rr]
endfor [Ee][Nn][Dd][Ff][Oo][Rr]
while [Ww][Hh][Ii][Ll][Ee]
endwhile [Ee][Nn][Dd][Ww][Hh][Ii][Ll][Ee]
declare [Dd][Ee][Cc][Ll][Aa][Rr][Ee]
as [Aa][Ss]
integer [Ii][Nn][Tt][Ee][Gg][Ee][Rr]
real [Rr][Ee][Aa][Ll]
string [Ss][Tt][Rr][Ii][Nn][Gg]
to [Tt][Oo]
downto [Dd][Oo][Ww][Nn][Tt][Oo]

%%

{empty_word} {
    line_word_count += yyleng;
}
{new_line} {
    line_count += 1;
    line_word_count = 0;
}
{line_comment} {
    if (yytext[yyleng - 1] == '\n') {
        line_count += 1;
        line_word_count = 0;
    }
}
{multi_line_comment} {
    is_multi_line_comment = !is_multi_line_comment;
}

{program} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "PROGRAM", yytext);
        return PROGRAM_MICOREX;
    }
}

{begin} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "BEGIN", yytext);
        return BEGIN_MICOREX;
    }
}
{end} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "END", yytext);
        return END_MICOREX;
    }
}
{read} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "READ", yytext);
        return READ_MICOREX;
    }
}
{write} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "WRITE", yytext);
        return WRITE_MICOREX;
    }
}
{integer_literal} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        yylval.int_val = atoi(yytext);
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "INTEGER_LITERAL", yytext);
        return INTEGER_LITERAL_MICOREX;
    }
}
{float_literal} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        yylval.double_val = atof(yytext);
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "FLOAT_LITERAL", yytext);
        return FLOAT_LITERAL_MICOREX;
    }
}
{exp_float_literal} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        yylval.double_val = atof(yytext);
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "EXP_FLOAT_LITERAL", yytext);
        return EXP_FLOAT_LITERAL_MICOREX;
    }
}
{string_literal} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        yylval.str_val = strdup(yytext);
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "STRING_LITERAL", yytext);
        return STRING_LITERAL_MICOREX;
    }
}
{left_parent} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "LEFT_PARENT", yytext);
        return LEFT_PARENT_MICOREX;
    }
}
{right_parent} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "RIGHT_PARENT", yytext);
        return RIGHT_PARENT_MICOREX;
    }
}
{left_bracket} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "LEFT_BRACKET", yytext);
        return LEFT_BRACKET_MICOREX;
    }
}
{right_bracket} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "RIGHT_BRACKET", yytext);
        return RIGHT_BRACKET_MICOREX;
    }
}
{semicolon} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "SEMICOLON", yytext);
        return SEMICOLON_MICOREX;
    }
}
{comma} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "COMMA", yytext);
        return COMMA_MICOREX;
    }
}
{assign} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "ASSIGN", yytext);
        return ASSIGN_MICOREX;
    }
}
{plus} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "PLUS", yytext);
        return PLUS_MICOREX;
    }
}
{minus} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "MINUS", yytext);
        return MINUS_MICOREX;
    }
}
{multiply} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "MULTIPLY", yytext);
        return MULTIPLY_MICOREX;
    }
}
{division} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "DIVISION", yytext);
        return DIVISION_MICOREX;
    }
}
{not_equal} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "NOT_EQUAL", yytext);
        return NOT_EQUAL_MICOREX;
    }
}
{great} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "GREAT", yytext);
        return GREAT_MICOREX;
    }
}
{less} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "LESS", yytext);
        return LESS_MICOREX;
    }
}
{great_equal} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "GREAT_EQUAL", yytext);
        return GREAT_EQUAL_MICOREX;
    }
}
{less_equal} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "LESS_EQUAL", yytext);
        return LESS_EQUAL_MICOREX;
    }
}
{equal} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "EQUAL", yytext);
        return EQUAL_MICOREX;
    }
}
{if} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "IF", yytext);
        return IF_MICOREX;
    }
}
{then} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "THEN", yytext);
        return THEN_MICOREX;
    }
}
{else} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "ELSE", yytext);
        return ELSE_MICOREX;
    }
}
{endif} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "ENDIF", yytext);
        return ENDIF_MICOREX;
    }
}
{for} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "FOR", yytext);
        return FOR_MICOREX;
    }
}
{to} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "TO", yytext);
        return TO_MICOREX;
    }
}
{downto} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "DOWNTO", yytext);
        return DOWNTO_MICOREX;
    }
}
{endfor} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "ENDFOR", yytext);
        return ENDFOR_MICOREX;
    }
}
{while} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "WHILE", yytext);
        return WHILE_MICOREX;
    }
}
{endwhile} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "ENDWHILE", yytext);
        return ENDWHILE_MICOREX;
    }
}
{declare} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "DECLARE", yytext);
        return DECLARE_MICOREX;
    }
}
{as} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "AS", yytext);
        return AS_MICOREX;
    }
}
{integer} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "INTEGER", yytext);
        yylval.type = TYPE_INT;
        return INTEGER_MICOREX;
    }
}
{real} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "REAL", yytext);
        yylval.type = TYPE_DOUBLE;
        return REAL_MICOREX;
    }
}
{string} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "STRING", yytext);
        yylval.type = TYPE_STRING;
        return STRING_MICOREX;
    }
}

{id} {
    line_word_count += yyleng;
    if (!is_multi_line_comment) {
        printf("\t$ lexer got token: `%s`, scan: `%s`\n", "ID", yytext);
        yylval.symbol_ptr = get_symbol(yytext);
        return ID_MICOREX;
    }
}

. {
    line_word_count += yyleng;
    if (!is_multi_line_comment)  {
        sprintf(error_msg, "Unexcept character: `%s`", yytext);
        yyerror(error_msg);
        return -1; /* lexical error: Unexcept character */
    }
}

%%

char *data_type_to_string(data_type type) {
    switch (type) {
        case TYPE_INT:
            return strdup("integer");
        case TYPE_DOUBLE:
            return strdup("real");
        case TYPE_STRING:
            return strdup("string");
        case TYPE_PROGRAM_NAME:
            return strdup("program");
        default:
            yyerror("Unknown data type");
    }
}

symbol *get_symbol(const char *name) {
    symbol *s;
    HASH_FIND_STR(symbol_table, name, s); // s = NULL if not found
    if (s != NULL) {
        return s;
    }

    add_symbol(name);
    HASH_FIND_STR(symbol_table, name, s);
    return s;
}

void add_symbol(const char *name) {
    symbol *s = (symbol *)malloc(sizeof(symbol));
    if (s == NULL) {
        yyerror("Out of memory when malloc.");
    }

    s->name = strdup(name);
    s->type = TYPE_UNKNOWN;
    s->array_info.dimensions = 0;
    s->array_info.dimension_sizes = NULL;

    HASH_ADD_STR(symbol_table, name, s);
}

void free_symbol_table() {
    symbol *current_symbol, *symbol_tmp;
    HASH_ITER(hh, symbol_table, current_symbol, symbol_tmp) {
        HASH_DEL(symbol_table, current_symbol);
        free(current_symbol->name);
        if (current_symbol->type == TYPE_STRING) {
            free(current_symbol->value.str_val);
        }
        free(current_symbol);
    }
}

void yyerror(const char *msg) {
    fprintf(stderr, "Error: %s\nat line (%llu:%llu)\n", msg, line_count, line_word_count);
    exit(EXIT_FAILURE);
}

// for Bison yacc to call parser
int main(int argc, char **argv) {
    if (argc == 2) {
        FILE *fp = fopen(argv[1], "r");
        if (fp == NULL) {
            printf("Error opening file: %s\n", argv[1]);
            return EXIT_FAILURE;
        }
        yyin = fp;
    }
    else {
        printf("Usage: %s <filename>\n", argv[0]);
        return EXIT_FAILURE;
    }

    int result = yyparse();
    
    if (is_multi_line_comment) {
        printf("lexcial error in line(%llu:%llu): Unbalance multi-line comment\n", line_count, line_word_count);
        return 1001; /* lexical error: Unexcept character */
    }

    free_symbol_table();

    fclose(yyin);

    return result;
}
[?2004h]0;asadfgglie-msi@asadfgglie-msi: ~/complier[01;32masadfgglie-msi@asadfgglie-msi[00m:[01;34m~/complier[00m$ cat microex/microex_scanner.l [K[K[K[K[K[K[K[K[K[Kparser.y 
[?2004l
%{
    #include "../microex/util.h"

    symbol *symbol_table = NULL;

    node* id_list_head = NULL;
    node* id_list_tail = NULL;

    void add_node(symbol* symbol_ptr) {
        node* new_node = (node*)malloc(sizeof(node));
        new_node->symbol_ptr = symbol_ptr;
        new_node->next = NULL;

        if (id_list_head == NULL) {
            id_list_head = new_node;
            id_list_tail = new_node;
        } else {
            id_list_tail->next = new_node;
            id_list_tail = new_node;
        }
    }
    void free_node_list() {
        node* current = id_list_head;
        node* next_node;

        while (current != NULL) {
            next_node = current->next;
            free(current);
            current = next_node;
        }

        id_list_head = NULL;
        id_list_tail = NULL;
    }
%}

%union {
    int int_val;
    char *str_val;
    double double_val;
    symbol *symbol_ptr;
    data_type type;
    array_type array_info;
}

%token PROGRAM_MICOREX
%token BEGIN_MICOREX
%token END_MICOREX
%token READ_MICOREX
%token WRITE_MICOREX
%token <symbol_ptr> ID_MICOREX
%token <int_val> INTEGER_LITERAL_MICOREX
%token <double_val> FLOAT_LITERAL_MICOREX
%token <double_val> EXP_FLOAT_LITERAL_MICOREX
%token <str_val> STRING_LITERAL_MICOREX
%token LEFT_PARENT_MICOREX
%token RIGHT_PARENT_MICOREX
%token LEFT_BRACKET_MICOREX
%token RIGHT_BRACKET_MICOREX
%token SEMICOLON_MICOREX
%token COMMA_MICOREX
%token ASSIGN_MICOREX
%token PLUS_MICOREX
%token MINUS_MICOREX
%token MULTIPLY_MICOREX
%token DIVISION_MICOREX
%token NOT_EQUAL_MICOREX
%token EQUAL_MICOREX
%token GREAT_MICOREX
%token LESS_MICOREX
%token GREAT_EQUAL_MICOREX
%token LESS_EQUAL_MICOREX
%token IF_MICOREX
%token THEN_MICOREX
%token ELSE_MICOREX
%token ENDIF_MICOREX
%token FOR_MICOREX
%token ENDFOR_MICOREX
%token WHILE_MICOREX
%token ENDWHILE_MICOREX
%token DECLARE_MICOREX
%token AS_MICOREX
%token <type> INTEGER_MICOREX
%token <type> REAL_MICOREX
%token <type> STRING_MICOREX
%token TO_MICOREX
%token DOWNTO_MICOREX

%type <type> type
%type <symbol_ptr> program_title
%type <symbol_ptr> id_list
%type <symbol_ptr> id
%type <array_info> array_dimension
%type <array_info> array_dimension_list

%%

program:
    program_title
    program_body {
        printf("halt %s\n", $1->name);
        printf("\t> program -> program_title program_body\n");
        printf("\t\t> Program done with name: `%s`\n", $1->name);
    }
    ;
program_title:
    PROGRAM_MICOREX ID_MICOREX {
        $2->type = TYPE_PROGRAM_NAME;
        $$ = $2;
        printf("start %s\n", $2->name);
        printf("\t> program_title -> program id (program_title -> program %s)\n", $2->name);
        printf("\t\t> Program start with name: `%s`\n", $2->name);
    }
    ;
program_body:
    BEGIN_MICOREX
        statement_list
    END_MICOREX {
        printf("\t> program_body -> begin statement_list end\n");
    }
    ;
statement_list:
    statement {
        printf("\t> statement_list -> statement\n");
    }
    | statement_list statement {
        printf("\t> statement_list -> statement_list statement\n");
    }
    ;
statement:
    declare_statement {
        printf("\t> statement -> declare_statement\n");
    }
    /* 
    | assignment_statement
    | read_statement
    | write_statement
    | if_statement
    | for_statement
    | while_statement 
    */
    ;
declare_statement:
    DECLARE_MICOREX id_list AS_MICOREX type SEMICOLON_MICOREX {
        node *current = id_list_head;
        node *next;
        int ids_name_len = 1;
        while (current != NULL) {
            current->symbol_ptr->type = $4;
            printf("declare %s %s\n", current->symbol_ptr->name, data_type_to_string($4));
            ids_name_len += strlen(current->symbol_ptr->name);
            current = current->next;
        }
        char *ids_name = (char *)malloc(sizeof(char) * ids_name_len);
        if (ids_name == NULL) {
            yyerror("Out of memory when malloc.");
        }
        ids_name[0] = '\0';
        current = id_list_head;
        while (current != NULL) {
            if (ids_name[0] != '\0') {
                sprintf(ids_name, "%s, %s", ids_name, current->symbol_ptr->name);
            } else {
                sprintf(ids_name, "%s", current->symbol_ptr->name);
            }
            current = current->next;
        }
        printf("\t> declare_statement -> declare id_list as type semicolon (declare_statement -> declare %s as %s;)\n", ids_name, data_type_to_string($4));
        free(ids_name);
        free_node_list();
    }
    ;
id_list:
    id {
        $$ = $1;
        add_node($1);
        printf("\t> id_list -> id (id_list -> %s)\n", $1->name);
    }
    | id_list COMMA_MICOREX id {
        $$ = $1;
        add_node($3);
        int ids_name_len = 1;
        node *current = id_list_head;
        node *next;
        while (current != NULL) {
            ids_name_len += strlen(current->symbol_ptr->name);
            if (current->next != NULL) {
                ids_name_len += 2; // for ", "
            }
            current = current->next;
        }
        char *ids_name = (char *)malloc(sizeof(char) * ids_name_len);
        if (ids_name == NULL) {
            yyerror("Out of memory when malloc.");
        }
        ids_name[0] = '\0';
        current = id_list_head;
        while (current != NULL) {
            if (ids_name[0] != '\0') {
                sprintf(ids_name, "%s, %s", ids_name, current->symbol_ptr->name);
            } else {
                sprintf(ids_name, "%s", current->symbol_ptr->name);
            }
            current = current->next;
        }
        printf("\t> id_list -> id_list comma id (id_list -> %s)\n", ids_name);
        free(ids_name);
    }
    ;
id:
    ID_MICOREX {
        $$ = $1;
        printf("\t> id -> ID (id -> %s)\n", $1->name);
    }
    | ID_MICOREX array_dimension_list {
        $$ = $1;
        $$->array_info = $2;
        char *dimensions = (char *)malloc(sizeof(char) * $$->array_info.dimensions * 3);
        if (dimensions == NULL) {
            yyerror("Out of memory when malloc.");
        }
        dimensions[0] = '\0';
        for (int i = 0; i < $$->array_info.dimensions; i++) {
            sprintf(dimensions, "%s[%d]", dimensions, $$->array_info.dimension_sizes[i]);
        }
        printf("\t> id -> ID array_dimension_list (id -> %s%s)\n", $1->name, dimensions);
        free(dimensions);
    }
    ;
array_dimension:
    LEFT_BRACKET_MICOREX INTEGER_LITERAL_MICOREX RIGHT_BRACKET_MICOREX {
        $$.dimensions = 1;
        $$.dimension_sizes = (int *)malloc(sizeof(int) * $$.dimensions);
        if ($$.dimension_sizes == NULL) {
            yyerror("Out of memory when malloc.");
        }
        $$.dimension_sizes[$$.dimensions - 1] = $2;
        printf("\t> array_dimension -> LEFT_BRACKET INTEGER_LITERAL RIGHT_BRACKET (array_dimension -> [%d])\n", $2);
    }
    ;
array_dimension_list:
    array_dimension {
        $$ = $1;
        printf("\t> array_dimension_list -> array_dimension (array_dimension_list -> [%d])\n", $1.dimension_sizes[0]);
    }
    | array_dimension_list array_dimension {
        $$.dimensions = $1.dimensions + 1;
        $$.dimension_sizes = (int *)realloc($$.dimension_sizes, sizeof(int) * $$.dimensions);
        if ($$.dimension_sizes == NULL) {
            yyerror("Out of memory when realloc.");
        }
        $$.dimension_sizes[$$.dimensions - 1] = $2.dimension_sizes[0];
        char *dimensions = (char *)malloc(sizeof(char) * $$.dimensions * 3);
        if (dimensions == NULL) {
            yyerror("Out of memory when malloc.");
        }
        dimensions[0] = '\0';
        for (int i = 0; i < $$.dimensions; i++) {
            sprintf(dimensions, "%s[%d]", dimensions, $$.dimension_sizes[i]);
        }
        printf("\t> array_dimension_list -> array_dimension_list array_dimension (array_dimension_list -> %s)\n", dimensions);
        free(dimensions);
    }
    ;

type:
    INTEGER_MICOREX {
        $$ = $1;
        printf("\t> type -> INTEGER\n");
    }
    | REAL_MICOREX {
        $$ = $1;
        printf("\t> type -> REAL\n");
    }
    | STRING_MICOREX {
        $$ = $1;
        printf("\t> type -> STRING\n");
    }
    ;

%%
[?2004h]0;asadfgglie-msi@asadfgglie-msi: ~/complier[01;32masadfgglie-msi@asadfgglie-msi[00m:[01;34m~/complier[00m$ cat microex/microex_parser.y [1@scanner.l[C../CompilerPrograms/ch3-04.yl[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[K[Kmakecmakeamaketmake make[C[C[C[Cfile 
[?2004l
.PHONY: clean build_hw test

build_hw: build/microex_c_hw
	@cp build/microex_c_hw microex_c_hw

build/microex_c_hw: build/lex_hw.yy.c
	@mkdir -p build
	@gcc -o build/microex_c_hw build/lex_hw.yy.c -lfl

build/lex_hw.yy.c: microex/microex_scanner_hw.l
	@mkdir -p build
	@lex -o build/lex_hw.yy.c microex/microex_scanner_hw.l

build: build/microex_c
	@cp build/microex_c microex_c

build/microex_c: build/lex.yy.c build/y.tab.c build/y.tab.h
	@mkdir -p build
	@gcc -o build/microex_c build/y.tab.c build/lex.yy.c -lfl

build/y.tab.c build/y.tab.h: microex/microex_parser.y
	@mkdir -p build
	@yacc -d -o build/y.tab.c microex/microex_parser.y

build/lex.yy.c: microex/microex_scanner.l
	@mkdir -p build
	@lex -o build/lex.yy.c microex/microex_scanner.l

clean:
	@rm -rf build
	@rm -f microex_c*
	@rm -f test/result/*

test: build/microex_c_hw
	@./test_hw.sh
[?2004h]0;asadfgglie-msi@asadfgglie-msi: ~/complier[01;32masadfgglie-msi@asadfgglie-msi[00m:[01;34m~/complier[00m$ cat makefile [16@icroex/microex_parser.y[C[1@scanner.l[C[1Pparser.y[C[16Pakefile[C[Kmake build
[?2004l
[?2004h]0;asadfgglie-msi@asadfgglie-msi: ~/complier[01;32masadfgglie-msi@asadfgglie-msi[00m:[01;34m~/complier[00m$ ./microex_c .[Ktest/test_exr8.microex 
[?2004l
	$ lexer got token: `PROGRAM`, scan: `Program`
	$ lexer got token: `ID`, scan: `Mypro`
start Mypro
	> program_title -> program id (program_title -> program Mypro)
		> Program start with name: `Mypro`
	$ lexer got token: `BEGIN`, scan: `Begin`
	$ lexer got token: `DECLARE`, scan: `declare`
	$ lexer got token: `ID`, scan: `A`
	$ lexer got token: `COMMA`, scan: `,`
	> id -> ID (id -> A)
	> id_list -> id (id_list -> A)
	$ lexer got token: `ID`, scan: `I`
	$ lexer got token: `AS`, scan: `as`
	> id -> ID (id -> I)
	> id_list -> id_list comma id (id_list -> A, I)
	$ lexer got token: `INTEGER`, scan: `integer`
	> type -> INTEGER
	$ lexer got token: `SEMICOLON`, scan: `;`
declare A integer
declare I integer
	> declare_statement -> declare id_list as type semicolon (declare_statement -> declare A, I as integer;)
	> statement -> declare_statement
	> statement_list -> statement
	$ lexer got token: `DECLARE`, scan: `Declare`
	$ lexer got token: `ID`, scan: `B`
	$ lexer got token: `COMMA`, scan: `,`
	> id -> ID (id -> B)
	> id_list -> id (id_list -> B)
	$ lexer got token: `ID`, scan: `C`
	$ lexer got token: `COMMA`, scan: `,`
	> id -> ID (id -> C)
	> id_list -> id_list comma id (id_list -> B, C)
	$ lexer got token: `ID`, scan: `D`
	$ lexer got token: `COMMA`, scan: `,`
	> id -> ID (id -> D)
	> id_list -> id_list comma id (id_list -> B, C, D)
	$ lexer got token: `ID`, scan: `size`
	$ lexer got token: `COMMA`, scan: `,`
	> id -> ID (id -> size)
	> id_list -> id_list comma id (id_list -> B, C, D, size)
	$ lexer got token: `ID`, scan: `LLL`
	$ lexer got token: `LEFT_BRACKET`, scan: `[`
	$ lexer got token: `INTEGER_LITERAL`, scan: `100`
	$ lexer got token: `RIGHT_BRACKET`, scan: `]`
	> array_dimension -> LEFT_BRACKET INTEGER_LITERAL RIGHT_BRACKET (array_dimension -> [100])
	> array_dimension_list -> array_dimension (array_dimension_list -> [100])
	$ lexer got token: `AS`, scan: `as`
	> id -> ID array_dimension_list (id -> LLL[100])
	> id_list -> id_list comma id (id_list -> B, C, D, size, LLL)
	$ lexer got token: `REAL`, scan: `Real`
	> type -> REAL
	$ lexer got token: `SEMICOLON`, scan: `;`
declare B real
declare C real
declare D real
declare size real
declare LLL real
	> declare_statement -> declare id_list as type semicolon (declare_statement -> declare B, C, D, size, LLL as real;)
	> statement -> declare_statement
	> statement_list -> statement_list statement
	$ lexer got token: `END`, scan: `end`
	> program_body -> begin statement_list end
halt Mypro
	> program -> program_title program_body
		> Program done with name: `Mypro`
[?2004h]0;asadfgglie-msi@asadfgglie-msi: ~/complier[01;32masadfgglie-msi@asadfgglie-msi[00m:[01;34m~/complier[00m$ exit
[?2004l
exit

Script done on 2025-05-22 02:38:17+08:00 [COMMAND_EXIT_CODE="0"]
